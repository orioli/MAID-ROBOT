// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __OpenHRPCommon_hh__
#define __OpenHRPCommon_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE OpenHRP

_CORBA_MODULE_BEG

  class DblSequence_var;

  class DblSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DblSequence_var _var_type;
    inline DblSequence() {}
    inline DblSequence(const DblSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DblSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DblSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DblSequence& operator = (const DblSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSequence_out;

  class DblSequence_var {
  public:
    inline DblSequence_var() : _pd_seq(0) {}
    inline DblSequence_var(DblSequence* _s) : _pd_seq(_s) {}
    inline DblSequence_var(const DblSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSequence_var& operator = (DblSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSequence_var& operator = (const DblSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSequence* operator -> () { return _pd_seq; }
    inline const DblSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSequence& () const { return *_pd_seq; }
#else
    inline operator const DblSequence& () const { return *_pd_seq; }
    inline operator DblSequence& () { return *_pd_seq; }
#endif
      
    inline const DblSequence& in() const { return *_pd_seq; }
    inline DblSequence&       inout()    { return *_pd_seq; }
    inline DblSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSequence* _retn() { DblSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSequence_out;
    
  private:
    DblSequence* _pd_seq;
  };

  class DblSequence_out {
  public:
    inline DblSequence_out(DblSequence*& _s) : _data(_s) { _data = 0; }
    inline DblSequence_out(DblSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DblSequence*) 0; }
    inline DblSequence_out(const DblSequence_out& _s) : _data(_s._data) {}
    inline DblSequence_out& operator = (const DblSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSequence_out& operator = (DblSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSequence*&()  { return _data; }
    inline DblSequence*& ptr()       { return _data; }
    inline DblSequence* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSequence*& _data;

  private:
    DblSequence_out();
    DblSequence_out& operator=(const DblSequence_var&);
  };

  class StringSequence_var;

  class StringSequence : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringSequence_var _var_type;
    inline StringSequence() {}
    inline StringSequence(const StringSequence& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringSequence& operator = (const StringSequence& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringSequence_out;

  class StringSequence_var {
  public:
    inline StringSequence_var() : _pd_seq(0) {}
    inline StringSequence_var(StringSequence* _s) : _pd_seq(_s) {}
    inline StringSequence_var(const StringSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new StringSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~StringSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline StringSequence_var& operator = (StringSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringSequence_var& operator = (const StringSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new StringSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringSequence* operator -> () { return _pd_seq; }
    inline const StringSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringSequence& () const { return *_pd_seq; }
#else
    inline operator const StringSequence& () const { return *_pd_seq; }
    inline operator StringSequence& () { return *_pd_seq; }
#endif
      
    inline const StringSequence& in() const { return *_pd_seq; }
    inline StringSequence&       inout()    { return *_pd_seq; }
    inline StringSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringSequence* _retn() { StringSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringSequence_out;
    
  private:
    StringSequence* _pd_seq;
  };

  class StringSequence_out {
  public:
    inline StringSequence_out(StringSequence*& _s) : _data(_s) { _data = 0; }
    inline StringSequence_out(StringSequence_var& _s)
      : _data(_s._pd_seq) { _s = (StringSequence*) 0; }
    inline StringSequence_out(const StringSequence_out& _s) : _data(_s._data) {}
    inline StringSequence_out& operator = (const StringSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringSequence_out& operator = (StringSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringSequence*&()  { return _data; }
    inline StringSequence*& ptr()       { return _data; }
    inline StringSequence* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringSequence*& _data;

  private:
    StringSequence_out();
    StringSequence_out& operator=(const StringSequence_var&);
  };

  class LongSequence_var;

  class LongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef LongSequence_var _var_type;
    inline LongSequence() {}
    inline LongSequence(const LongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline LongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline LongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline LongSequence& operator = (const LongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class LongSequence_out;

  class LongSequence_var {
  public:
    inline LongSequence_var() : _pd_seq(0) {}
    inline LongSequence_var(LongSequence* _s) : _pd_seq(_s) {}
    inline LongSequence_var(const LongSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LongSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LongSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LongSequence_var& operator = (LongSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LongSequence_var& operator = (const LongSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LongSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LongSequence* operator -> () { return _pd_seq; }
    inline const LongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LongSequence& () const { return *_pd_seq; }
#else
    inline operator const LongSequence& () const { return *_pd_seq; }
    inline operator LongSequence& () { return *_pd_seq; }
#endif
      
    inline const LongSequence& in() const { return *_pd_seq; }
    inline LongSequence&       inout()    { return *_pd_seq; }
    inline LongSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LongSequence* _retn() { LongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LongSequence_out;
    
  private:
    LongSequence* _pd_seq;
  };

  class LongSequence_out {
  public:
    inline LongSequence_out(LongSequence*& _s) : _data(_s) { _data = 0; }
    inline LongSequence_out(LongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LongSequence*) 0; }
    inline LongSequence_out(const LongSequence_out& _s) : _data(_s._data) {}
    inline LongSequence_out& operator = (const LongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LongSequence_out& operator = (LongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LongSequence*&()  { return _data; }
    inline LongSequence*& ptr()       { return _data; }
    inline LongSequence* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LongSequence*& _data;

  private:
    LongSequence_out();
    LongSequence_out& operator=(const LongSequence_var&);
  };

  typedef ::CORBA::Double DblArray3[3];
  typedef ::CORBA::Double DblArray3_slice;

  _CORBA_MODULE_INLINE DblArray3_slice* DblArray3_alloc() {
    return new DblArray3_slice[3];
  }

  _CORBA_MODULE_INLINE DblArray3_slice* DblArray3_dup(const DblArray3_slice* _s) {
    if (!_s) return 0;
    DblArray3_slice* _data = DblArray3_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 3; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void DblArray3_copy(DblArray3_slice* _to, const DblArray3_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 3; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  _CORBA_MODULE_INLINE void DblArray3_free(DblArray3_slice* _s) {
      delete [] _s;
  }

  class DblArray3_copyHelper {
  public:
    static inline DblArray3_slice* alloc() { return DblArray3_alloc(); }
    static inline DblArray3_slice* dup(const DblArray3_slice* p) { return DblArray3_dup(p); }
    static inline void free(DblArray3_slice* p) { DblArray3_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<DblArray3_copyHelper,DblArray3_slice> DblArray3_var;
  typedef _CORBA_Array_Fix_Forany<DblArray3_copyHelper,DblArray3_slice> DblArray3_forany;

  typedef DblArray3_slice* DblArray3_out;

  typedef ::CORBA::Double DblArray6[6];
  typedef ::CORBA::Double DblArray6_slice;

  _CORBA_MODULE_INLINE DblArray6_slice* DblArray6_alloc() {
    return new DblArray6_slice[6];
  }

  _CORBA_MODULE_INLINE DblArray6_slice* DblArray6_dup(const DblArray6_slice* _s) {
    if (!_s) return 0;
    DblArray6_slice* _data = DblArray6_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 6; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void DblArray6_copy(DblArray6_slice* _to, const DblArray6_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 6; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  _CORBA_MODULE_INLINE void DblArray6_free(DblArray6_slice* _s) {
      delete [] _s;
  }

  class DblArray6_copyHelper {
  public:
    static inline DblArray6_slice* alloc() { return DblArray6_alloc(); }
    static inline DblArray6_slice* dup(const DblArray6_slice* p) { return DblArray6_dup(p); }
    static inline void free(DblArray6_slice* p) { DblArray6_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<DblArray6_copyHelper,DblArray6_slice> DblArray6_var;
  typedef _CORBA_Array_Fix_Forany<DblArray6_copyHelper,DblArray6_slice> DblArray6_forany;

  typedef DblArray6_slice* DblArray6_out;

  typedef ::CORBA::Double DblArray9[9];
  typedef ::CORBA::Double DblArray9_slice;

  _CORBA_MODULE_INLINE DblArray9_slice* DblArray9_alloc() {
    return new DblArray9_slice[9];
  }

  _CORBA_MODULE_INLINE DblArray9_slice* DblArray9_dup(const DblArray9_slice* _s) {
    if (!_s) return 0;
    DblArray9_slice* _data = DblArray9_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 9; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  _CORBA_MODULE_INLINE void DblArray9_copy(DblArray9_slice* _to, const DblArray9_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 9; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  _CORBA_MODULE_INLINE void DblArray9_free(DblArray9_slice* _s) {
      delete [] _s;
  }

  class DblArray9_copyHelper {
  public:
    static inline DblArray9_slice* alloc() { return DblArray9_alloc(); }
    static inline DblArray9_slice* dup(const DblArray9_slice* p) { return DblArray9_dup(p); }
    static inline void free(DblArray9_slice* p) { DblArray9_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<DblArray9_copyHelper,DblArray9_slice> DblArray9_var;
  typedef _CORBA_Array_Fix_Forany<DblArray9_copyHelper,DblArray9_slice> DblArray9_forany;

  typedef DblArray9_slice* DblArray9_out;

  class DblSequence3_var;

  class DblSequence3 : public _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 >  {
  public:
    typedef DblSequence3_var _var_type;
    inline DblSequence3() {}
    inline DblSequence3(const DblSequence3& _s)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > (_s) {}

    inline DblSequence3(_CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > (_len, _val, _rel) {}

  

    inline DblSequence3& operator = (const DblSequence3& _s) {
      _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 3, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSequence3_out;

  class DblSequence3_var {
  public:
    inline DblSequence3_var() : _pd_seq(0) {}
    inline DblSequence3_var(DblSequence3* _s) : _pd_seq(_s) {}
    inline DblSequence3_var(const DblSequence3_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSequence3(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSequence3_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSequence3_var& operator = (DblSequence3* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSequence3_var& operator = (const DblSequence3_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSequence3;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSequence3* operator -> () { return _pd_seq; }
    inline const DblSequence3* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSequence3& () const { return *_pd_seq; }
#else
    inline operator const DblSequence3& () const { return *_pd_seq; }
    inline operator DblSequence3& () { return *_pd_seq; }
#endif
      
    inline const DblSequence3& in() const { return *_pd_seq; }
    inline DblSequence3&       inout()    { return *_pd_seq; }
    inline DblSequence3*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSequence3* _retn() { DblSequence3* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSequence3_out;
    
  private:
    DblSequence3* _pd_seq;
  };

  class DblSequence3_out {
  public:
    inline DblSequence3_out(DblSequence3*& _s) : _data(_s) { _data = 0; }
    inline DblSequence3_out(DblSequence3_var& _s)
      : _data(_s._pd_seq) { _s = (DblSequence3*) 0; }
    inline DblSequence3_out(const DblSequence3_out& _s) : _data(_s._data) {}
    inline DblSequence3_out& operator = (const DblSequence3_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSequence3_out& operator = (DblSequence3* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSequence3*&()  { return _data; }
    inline DblSequence3*& ptr()       { return _data; }
    inline DblSequence3* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSequence3*& _data;

  private:
    DblSequence3_out();
    DblSequence3_out& operator=(const DblSequence3_var&);
  };

  class DblSequence6_var;

  class DblSequence6 : public _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 6, 8, 8 >  {
  public:
    typedef DblSequence6_var _var_type;
    inline DblSequence6() {}
    inline DblSequence6(const DblSequence6& _s)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 6, 8, 8 > (_s) {}

    inline DblSequence6(_CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 6, 8, 8 > (_len, _val, _rel) {}

  

    inline DblSequence6& operator = (const DblSequence6& _s) {
      _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 6, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSequence6_out;

  class DblSequence6_var {
  public:
    inline DblSequence6_var() : _pd_seq(0) {}
    inline DblSequence6_var(DblSequence6* _s) : _pd_seq(_s) {}
    inline DblSequence6_var(const DblSequence6_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSequence6(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSequence6_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSequence6_var& operator = (DblSequence6* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSequence6_var& operator = (const DblSequence6_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSequence6;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSequence6* operator -> () { return _pd_seq; }
    inline const DblSequence6* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSequence6& () const { return *_pd_seq; }
#else
    inline operator const DblSequence6& () const { return *_pd_seq; }
    inline operator DblSequence6& () { return *_pd_seq; }
#endif
      
    inline const DblSequence6& in() const { return *_pd_seq; }
    inline DblSequence6&       inout()    { return *_pd_seq; }
    inline DblSequence6*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSequence6* _retn() { DblSequence6* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSequence6_out;
    
  private:
    DblSequence6* _pd_seq;
  };

  class DblSequence6_out {
  public:
    inline DblSequence6_out(DblSequence6*& _s) : _data(_s) { _data = 0; }
    inline DblSequence6_out(DblSequence6_var& _s)
      : _data(_s._pd_seq) { _s = (DblSequence6*) 0; }
    inline DblSequence6_out(const DblSequence6_out& _s) : _data(_s._data) {}
    inline DblSequence6_out& operator = (const DblSequence6_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSequence6_out& operator = (DblSequence6* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSequence6*&()  { return _data; }
    inline DblSequence6*& ptr()       { return _data; }
    inline DblSequence6* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSequence6*& _data;

  private:
    DblSequence6_out();
    DblSequence6_out& operator=(const DblSequence6_var&);
  };

  class DblSequence9_var;

  class DblSequence9 : public _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 >  {
  public:
    typedef DblSequence9_var _var_type;
    inline DblSequence9() {}
    inline DblSequence9(const DblSequence9& _s)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > (_s) {}

    inline DblSequence9(_CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > (_len, _val, _rel) {}

  

    inline DblSequence9& operator = (const DblSequence9& _s) {
      _CORBA_Bounded_Sequence_w_FixSizeElement< ::CORBA::Double, 9, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DblSequence9_out;

  class DblSequence9_var {
  public:
    inline DblSequence9_var() : _pd_seq(0) {}
    inline DblSequence9_var(DblSequence9* _s) : _pd_seq(_s) {}
    inline DblSequence9_var(const DblSequence9_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DblSequence9(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DblSequence9_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DblSequence9_var& operator = (DblSequence9* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DblSequence9_var& operator = (const DblSequence9_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DblSequence9;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DblSequence9* operator -> () { return _pd_seq; }
    inline const DblSequence9* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DblSequence9& () const { return *_pd_seq; }
#else
    inline operator const DblSequence9& () const { return *_pd_seq; }
    inline operator DblSequence9& () { return *_pd_seq; }
#endif
      
    inline const DblSequence9& in() const { return *_pd_seq; }
    inline DblSequence9&       inout()    { return *_pd_seq; }
    inline DblSequence9*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DblSequence9* _retn() { DblSequence9* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DblSequence9_out;
    
  private:
    DblSequence9* _pd_seq;
  };

  class DblSequence9_out {
  public:
    inline DblSequence9_out(DblSequence9*& _s) : _data(_s) { _data = 0; }
    inline DblSequence9_out(DblSequence9_var& _s)
      : _data(_s._pd_seq) { _s = (DblSequence9*) 0; }
    inline DblSequence9_out(const DblSequence9_out& _s) : _data(_s._data) {}
    inline DblSequence9_out& operator = (const DblSequence9_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DblSequence9_out& operator = (DblSequence9* _s) {
      _data = _s;
      return *this;
    }
    inline operator DblSequence9*&()  { return _data; }
    inline DblSequence9*& ptr()       { return _data; }
    inline DblSequence9* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DblSequence9*& _data;

  private:
    DblSequence9_out();
    DblSequence9_out& operator=(const DblSequence9_var&);
  };

  struct Transform {
    typedef _CORBA_ConstrType_Fix_Var<Transform> _var_type;

    
    ::CORBA::Double px;

    ::CORBA::Double py;

    ::CORBA::Double pz;

    ::CORBA::Double qw;

    ::CORBA::Double qx;

    ::CORBA::Double qy;

    ::CORBA::Double qz;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Transform::_var_type Transform_var;

  typedef Transform& Transform_out;

  struct LinkPosition {
    typedef _CORBA_ConstrType_Fix_Var<LinkPosition> _var_type;

    
    DblArray3 p;

    DblArray9 R;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LinkPosition::_var_type LinkPosition_var;

  typedef LinkPosition& LinkPosition_out;

  class LinkPositionSequence_var;

  class LinkPositionSequence : public _CORBA_Unbounded_Sequence< LinkPosition >  {
  public:
    typedef LinkPositionSequence_var _var_type;
    inline LinkPositionSequence() {}
    inline LinkPositionSequence(const LinkPositionSequence& _s)
      : _CORBA_Unbounded_Sequence< LinkPosition > (_s) {}

    inline LinkPositionSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LinkPosition > (_max) {}
    inline LinkPositionSequence(_CORBA_ULong _max, _CORBA_ULong _len, LinkPosition* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LinkPosition > (_max, _len, _val, _rel) {}

  

    inline LinkPositionSequence& operator = (const LinkPositionSequence& _s) {
      _CORBA_Unbounded_Sequence< LinkPosition > ::operator=(_s);
      return *this;
    }
  };

  class LinkPositionSequence_out;

  class LinkPositionSequence_var {
  public:
    inline LinkPositionSequence_var() : _pd_seq(0) {}
    inline LinkPositionSequence_var(LinkPositionSequence* _s) : _pd_seq(_s) {}
    inline LinkPositionSequence_var(const LinkPositionSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LinkPositionSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LinkPositionSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LinkPositionSequence_var& operator = (LinkPositionSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LinkPositionSequence_var& operator = (const LinkPositionSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LinkPositionSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LinkPosition& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LinkPositionSequence* operator -> () { return _pd_seq; }
    inline const LinkPositionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LinkPositionSequence& () const { return *_pd_seq; }
#else
    inline operator const LinkPositionSequence& () const { return *_pd_seq; }
    inline operator LinkPositionSequence& () { return *_pd_seq; }
#endif
      
    inline const LinkPositionSequence& in() const { return *_pd_seq; }
    inline LinkPositionSequence&       inout()    { return *_pd_seq; }
    inline LinkPositionSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LinkPositionSequence* _retn() { LinkPositionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LinkPositionSequence_out;
    
  private:
    LinkPositionSequence* _pd_seq;
  };

  class LinkPositionSequence_out {
  public:
    inline LinkPositionSequence_out(LinkPositionSequence*& _s) : _data(_s) { _data = 0; }
    inline LinkPositionSequence_out(LinkPositionSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LinkPositionSequence*) 0; }
    inline LinkPositionSequence_out(const LinkPositionSequence_out& _s) : _data(_s._data) {}
    inline LinkPositionSequence_out& operator = (const LinkPositionSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LinkPositionSequence_out& operator = (LinkPositionSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LinkPositionSequence*&()  { return _data; }
    inline LinkPositionSequence*& ptr()       { return _data; }
    inline LinkPositionSequence* operator->() { return _data; }

    inline LinkPosition& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LinkPositionSequence*& _data;

  private:
    LinkPositionSequence_out();
    LinkPositionSequence_out& operator=(const LinkPositionSequence_var&);
  };

  struct CharacterPosition {
    typedef _CORBA_ConstrType_Variable_Var<CharacterPosition> _var_type;

    
    ::CORBA::String_member characterName;

    LinkPositionSequence linkPositions;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CharacterPosition::_var_type CharacterPosition_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< CharacterPosition,CharacterPosition_var > CharacterPosition_out;

  class CharacterPositionSequence_var;

  class CharacterPositionSequence : public _CORBA_Unbounded_Sequence< CharacterPosition >  {
  public:
    typedef CharacterPositionSequence_var _var_type;
    inline CharacterPositionSequence() {}
    inline CharacterPositionSequence(const CharacterPositionSequence& _s)
      : _CORBA_Unbounded_Sequence< CharacterPosition > (_s) {}

    inline CharacterPositionSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CharacterPosition > (_max) {}
    inline CharacterPositionSequence(_CORBA_ULong _max, _CORBA_ULong _len, CharacterPosition* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CharacterPosition > (_max, _len, _val, _rel) {}

  

    inline CharacterPositionSequence& operator = (const CharacterPositionSequence& _s) {
      _CORBA_Unbounded_Sequence< CharacterPosition > ::operator=(_s);
      return *this;
    }
  };

  class CharacterPositionSequence_out;

  class CharacterPositionSequence_var {
  public:
    inline CharacterPositionSequence_var() : _pd_seq(0) {}
    inline CharacterPositionSequence_var(CharacterPositionSequence* _s) : _pd_seq(_s) {}
    inline CharacterPositionSequence_var(const CharacterPositionSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CharacterPositionSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CharacterPositionSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CharacterPositionSequence_var& operator = (CharacterPositionSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CharacterPositionSequence_var& operator = (const CharacterPositionSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CharacterPositionSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CharacterPosition& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CharacterPositionSequence* operator -> () { return _pd_seq; }
    inline const CharacterPositionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CharacterPositionSequence& () const { return *_pd_seq; }
#else
    inline operator const CharacterPositionSequence& () const { return *_pd_seq; }
    inline operator CharacterPositionSequence& () { return *_pd_seq; }
#endif
      
    inline const CharacterPositionSequence& in() const { return *_pd_seq; }
    inline CharacterPositionSequence&       inout()    { return *_pd_seq; }
    inline CharacterPositionSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CharacterPositionSequence* _retn() { CharacterPositionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CharacterPositionSequence_out;
    
  private:
    CharacterPositionSequence* _pd_seq;
  };

  class CharacterPositionSequence_out {
  public:
    inline CharacterPositionSequence_out(CharacterPositionSequence*& _s) : _data(_s) { _data = 0; }
    inline CharacterPositionSequence_out(CharacterPositionSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CharacterPositionSequence*) 0; }
    inline CharacterPositionSequence_out(const CharacterPositionSequence_out& _s) : _data(_s._data) {}
    inline CharacterPositionSequence_out& operator = (const CharacterPositionSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CharacterPositionSequence_out& operator = (CharacterPositionSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CharacterPositionSequence*&()  { return _data; }
    inline CharacterPositionSequence*& ptr()       { return _data; }
    inline CharacterPositionSequence* operator->() { return _data; }

    inline CharacterPosition& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CharacterPositionSequence*& _data;

  private:
    CharacterPositionSequence_out();
    CharacterPositionSequence_out& operator=(const CharacterPositionSequence_var&);
  };

  struct LinkPair {
    typedef _CORBA_ConstrType_Variable_Var<LinkPair> _var_type;

    
    ::CORBA::String_member charName1;

    ::CORBA::String_member linkName1;

    ::CORBA::String_member charName2;

    ::CORBA::String_member linkName2;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LinkPair::_var_type LinkPair_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LinkPair,LinkPair_var > LinkPair_out;

  class LinkPairSequence_var;

  class LinkPairSequence : public _CORBA_Unbounded_Sequence< LinkPair >  {
  public:
    typedef LinkPairSequence_var _var_type;
    inline LinkPairSequence() {}
    inline LinkPairSequence(const LinkPairSequence& _s)
      : _CORBA_Unbounded_Sequence< LinkPair > (_s) {}

    inline LinkPairSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LinkPair > (_max) {}
    inline LinkPairSequence(_CORBA_ULong _max, _CORBA_ULong _len, LinkPair* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LinkPair > (_max, _len, _val, _rel) {}

  

    inline LinkPairSequence& operator = (const LinkPairSequence& _s) {
      _CORBA_Unbounded_Sequence< LinkPair > ::operator=(_s);
      return *this;
    }
  };

  class LinkPairSequence_out;

  class LinkPairSequence_var {
  public:
    inline LinkPairSequence_var() : _pd_seq(0) {}
    inline LinkPairSequence_var(LinkPairSequence* _s) : _pd_seq(_s) {}
    inline LinkPairSequence_var(const LinkPairSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LinkPairSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LinkPairSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LinkPairSequence_var& operator = (LinkPairSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LinkPairSequence_var& operator = (const LinkPairSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LinkPairSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LinkPair& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LinkPairSequence* operator -> () { return _pd_seq; }
    inline const LinkPairSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LinkPairSequence& () const { return *_pd_seq; }
#else
    inline operator const LinkPairSequence& () const { return *_pd_seq; }
    inline operator LinkPairSequence& () { return *_pd_seq; }
#endif
      
    inline const LinkPairSequence& in() const { return *_pd_seq; }
    inline LinkPairSequence&       inout()    { return *_pd_seq; }
    inline LinkPairSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LinkPairSequence* _retn() { LinkPairSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LinkPairSequence_out;
    
  private:
    LinkPairSequence* _pd_seq;
  };

  class LinkPairSequence_out {
  public:
    inline LinkPairSequence_out(LinkPairSequence*& _s) : _data(_s) { _data = 0; }
    inline LinkPairSequence_out(LinkPairSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LinkPairSequence*) 0; }
    inline LinkPairSequence_out(const LinkPairSequence_out& _s) : _data(_s._data) {}
    inline LinkPairSequence_out& operator = (const LinkPairSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LinkPairSequence_out& operator = (LinkPairSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LinkPairSequence*&()  { return _data; }
    inline LinkPairSequence*& ptr()       { return _data; }
    inline LinkPairSequence* operator->() { return _data; }

    inline LinkPair& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LinkPairSequence*& _data;

  private:
    LinkPairSequence_out();
    LinkPairSequence_out& operator=(const LinkPairSequence_var&);
  };

  struct CollisionPoint {
    typedef _CORBA_ConstrType_Fix_Var<CollisionPoint> _var_type;

    
    DblArray3 position;

    DblArray3 normal;

    ::CORBA::Double idepth;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CollisionPoint::_var_type CollisionPoint_var;

  typedef CollisionPoint& CollisionPoint_out;

  class CollisionPointSequence_var;

  class CollisionPointSequence : public _CORBA_Unbounded_Sequence< CollisionPoint >  {
  public:
    typedef CollisionPointSequence_var _var_type;
    inline CollisionPointSequence() {}
    inline CollisionPointSequence(const CollisionPointSequence& _s)
      : _CORBA_Unbounded_Sequence< CollisionPoint > (_s) {}

    inline CollisionPointSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CollisionPoint > (_max) {}
    inline CollisionPointSequence(_CORBA_ULong _max, _CORBA_ULong _len, CollisionPoint* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CollisionPoint > (_max, _len, _val, _rel) {}

  

    inline CollisionPointSequence& operator = (const CollisionPointSequence& _s) {
      _CORBA_Unbounded_Sequence< CollisionPoint > ::operator=(_s);
      return *this;
    }
  };

  class CollisionPointSequence_out;

  class CollisionPointSequence_var {
  public:
    inline CollisionPointSequence_var() : _pd_seq(0) {}
    inline CollisionPointSequence_var(CollisionPointSequence* _s) : _pd_seq(_s) {}
    inline CollisionPointSequence_var(const CollisionPointSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CollisionPointSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CollisionPointSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CollisionPointSequence_var& operator = (CollisionPointSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CollisionPointSequence_var& operator = (const CollisionPointSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CollisionPointSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CollisionPoint& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CollisionPointSequence* operator -> () { return _pd_seq; }
    inline const CollisionPointSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CollisionPointSequence& () const { return *_pd_seq; }
#else
    inline operator const CollisionPointSequence& () const { return *_pd_seq; }
    inline operator CollisionPointSequence& () { return *_pd_seq; }
#endif
      
    inline const CollisionPointSequence& in() const { return *_pd_seq; }
    inline CollisionPointSequence&       inout()    { return *_pd_seq; }
    inline CollisionPointSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CollisionPointSequence* _retn() { CollisionPointSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CollisionPointSequence_out;
    
  private:
    CollisionPointSequence* _pd_seq;
  };

  class CollisionPointSequence_out {
  public:
    inline CollisionPointSequence_out(CollisionPointSequence*& _s) : _data(_s) { _data = 0; }
    inline CollisionPointSequence_out(CollisionPointSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CollisionPointSequence*) 0; }
    inline CollisionPointSequence_out(const CollisionPointSequence_out& _s) : _data(_s._data) {}
    inline CollisionPointSequence_out& operator = (const CollisionPointSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CollisionPointSequence_out& operator = (CollisionPointSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CollisionPointSequence*&()  { return _data; }
    inline CollisionPointSequence*& ptr()       { return _data; }
    inline CollisionPointSequence* operator->() { return _data; }

    inline CollisionPoint& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CollisionPointSequence*& _data;

  private:
    CollisionPointSequence_out();
    CollisionPointSequence_out& operator=(const CollisionPointSequence_var&);
  };

  struct Collision {
    typedef _CORBA_ConstrType_Variable_Var<Collision> _var_type;

    
    LinkPair pair;

    CollisionPointSequence points;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Collision::_var_type Collision_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Collision,Collision_var > Collision_out;

  class CollisionSequence_var;

  class CollisionSequence : public _CORBA_Unbounded_Sequence< Collision >  {
  public:
    typedef CollisionSequence_var _var_type;
    inline CollisionSequence() {}
    inline CollisionSequence(const CollisionSequence& _s)
      : _CORBA_Unbounded_Sequence< Collision > (_s) {}

    inline CollisionSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Collision > (_max) {}
    inline CollisionSequence(_CORBA_ULong _max, _CORBA_ULong _len, Collision* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Collision > (_max, _len, _val, _rel) {}

  

    inline CollisionSequence& operator = (const CollisionSequence& _s) {
      _CORBA_Unbounded_Sequence< Collision > ::operator=(_s);
      return *this;
    }
  };

  class CollisionSequence_out;

  class CollisionSequence_var {
  public:
    inline CollisionSequence_var() : _pd_seq(0) {}
    inline CollisionSequence_var(CollisionSequence* _s) : _pd_seq(_s) {}
    inline CollisionSequence_var(const CollisionSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CollisionSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CollisionSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CollisionSequence_var& operator = (CollisionSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CollisionSequence_var& operator = (const CollisionSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CollisionSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Collision& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CollisionSequence* operator -> () { return _pd_seq; }
    inline const CollisionSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CollisionSequence& () const { return *_pd_seq; }
#else
    inline operator const CollisionSequence& () const { return *_pd_seq; }
    inline operator CollisionSequence& () { return *_pd_seq; }
#endif
      
    inline const CollisionSequence& in() const { return *_pd_seq; }
    inline CollisionSequence&       inout()    { return *_pd_seq; }
    inline CollisionSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CollisionSequence* _retn() { CollisionSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CollisionSequence_out;
    
  private:
    CollisionSequence* _pd_seq;
  };

  class CollisionSequence_out {
  public:
    inline CollisionSequence_out(CollisionSequence*& _s) : _data(_s) { _data = 0; }
    inline CollisionSequence_out(CollisionSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CollisionSequence*) 0; }
    inline CollisionSequence_out(const CollisionSequence_out& _s) : _data(_s._data) {}
    inline CollisionSequence_out& operator = (const CollisionSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CollisionSequence_out& operator = (CollisionSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CollisionSequence*&()  { return _data; }
    inline CollisionSequence*& ptr()       { return _data; }
    inline CollisionSequence* operator->() { return _data; }

    inline Collision& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CollisionSequence*& _data;

  private:
    CollisionSequence_out();
    CollisionSequence_out& operator=(const CollisionSequence_var&);
  };

  struct WorldState {
    typedef _CORBA_ConstrType_Variable_Var<WorldState> _var_type;

    
    ::CORBA::Double time;

    CharacterPositionSequence characterPositions;

    CollisionSequence collisions;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef WorldState::_var_type WorldState_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< WorldState,WorldState_var > WorldState_out;

#ifndef __OpenHRP_mServerObject__
#define __OpenHRP_mServerObject__

  class ServerObject;
  class _objref_ServerObject;
  class _impl_ServerObject;
  
  typedef _objref_ServerObject* ServerObject_ptr;
  typedef ServerObject_ptr ServerObjectRef;

  class ServerObject_Helper {
  public:
    typedef ServerObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ServerObject, ServerObject_Helper> ServerObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ServerObject,ServerObject_Helper > ServerObject_out;

#endif

  // interface ServerObject
  class ServerObject {
  public:
    // Declarations for this interface type.
    typedef ServerObject_ptr _ptr_type;
    typedef ServerObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ServerObject :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void shutdown();

    inline _objref_ServerObject()  { _PR_setobj(0); }  // nil
    _objref_ServerObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ServerObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ServerObject(const _objref_ServerObject&);
    _objref_ServerObject& operator = (const _objref_ServerObject&);
    // not implemented

    friend class ServerObject;
  };

  class _pof_ServerObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ServerObject() : _OMNI_NS(proxyObjectFactory)(ServerObject::_PD_repoId) {}
    virtual ~_pof_ServerObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ServerObject :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ServerObject();

    virtual void shutdown() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_OpenHRP
_CORBA_MODULE_BEG

  class ServerObject :
    public virtual OpenHRP::_impl_ServerObject,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ServerObject();

    inline ::OpenHRP::ServerObject_ptr _this() {
      return (::OpenHRP::ServerObject_ptr) _do_this(::OpenHRP::ServerObject::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_OpenHRP
_CORBA_MODULE_BEG

_CORBA_MODULE_END



template <class _omniT>
class POA_OpenHRP_ServerObject_tie : public virtual POA_OpenHRP::ServerObject
{
public:
  POA_OpenHRP_ServerObject_tie(_omniT& t)
    : pd_obj(&t), pd_poa(0), pd_rel(0) {}
  POA_OpenHRP_ServerObject_tie(_omniT& t, ::PortableServer::POA_ptr p)
    : pd_obj(&t), pd_poa(p), pd_rel(0) {}
  POA_OpenHRP_ServerObject_tie(_omniT* t, _CORBA_Boolean r=1)
    : pd_obj(t), pd_poa(0), pd_rel(r) {}
  POA_OpenHRP_ServerObject_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
    : pd_obj(t), pd_poa(p), pd_rel(r) {}
  ~POA_OpenHRP_ServerObject_tie() {
    if( pd_poa )  ::CORBA::release(pd_poa);
    if( pd_rel )  delete pd_obj;
  }

  _omniT* _tied_object() { return pd_obj; }

  void _tied_object(_omniT& t) {
    if( pd_rel )  delete pd_obj;
    pd_obj = &t;
    pd_rel = 0;
  }

  void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
    if( pd_rel )  delete pd_obj;
    pd_obj = t;
    pd_rel = r;
  }

  _CORBA_Boolean _is_owner()        { return pd_rel; }
  void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

  ::PortableServer::POA_ptr _default_POA() {
    if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
    else           return ::PortableServer::POA::_duplicate(pd_poa);
  }

  void shutdown() { pd_obj->shutdown(); }


private:
  _omniT*                   pd_obj;
  ::PortableServer::POA_ptr pd_poa;
  _CORBA_Boolean            pd_rel;
};



#undef _core_attr
#undef _dyn_attr



inline void
OpenHRP::ServerObject::_marshalObjRef(::OpenHRP::ServerObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_OpenHRPCommon
#endif

#endif  // __OpenHRPCommon_hh__

