// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __coordServer_hh__
#define __coordServer_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





#ifndef __coordServer__
#define __coordServer__

class coordServer;
class _objref_coordServer;
class _impl_coordServer;

typedef _objref_coordServer* coordServer_ptr;
typedef coordServer_ptr coordServerRef;

class coordServer_Helper {
public:
  typedef coordServer_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_coordServer, coordServer_Helper> coordServer_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_coordServer,coordServer_Helper > coordServer_out;

#endif

// interface coordServer
class coordServer {
public:
  // Declarations for this interface type.
  typedef coordServer_ptr _ptr_type;
  typedef coordServer_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  static _core_attr const ::CORBA::Octet WorldCS _init_in_cldecl_( = 0 );

  static _core_attr const ::CORBA::Octet FrontCS _init_in_cldecl_( = 1 );

  static _core_attr const ::CORBA::Octet RWristCS _init_in_cldecl_( = 2 );

  static _core_attr const ::CORBA::Octet LWristCS _init_in_cldecl_( = 3 );

  static _core_attr const ::CORBA::Octet NeckCS _init_in_cldecl_( = 4 );

  static _core_attr const ::CORBA::Octet RHand0 _init_in_cldecl_( = 16 );

  static _core_attr const ::CORBA::Octet RHand1 _init_in_cldecl_( = 17 );

  static _core_attr const ::CORBA::Octet RHand2 _init_in_cldecl_( = 18 );

  static _core_attr const ::CORBA::Octet RHand3 _init_in_cldecl_( = 19 );

  static _core_attr const ::CORBA::Octet RHand4 _init_in_cldecl_( = 20 );

  static _core_attr const ::CORBA::Octet RHand5 _init_in_cldecl_( = 21 );

  static _core_attr const ::CORBA::Octet RHand6 _init_in_cldecl_( = 22 );

  static _core_attr const ::CORBA::Octet RHand7 _init_in_cldecl_( = 23 );

  static _core_attr const ::CORBA::Octet LHand0 _init_in_cldecl_( = 24 );

  static _core_attr const ::CORBA::Octet LHand1 _init_in_cldecl_( = 25 );

  static _core_attr const ::CORBA::Octet LHand2 _init_in_cldecl_( = 26 );

  static _core_attr const ::CORBA::Octet LHand3 _init_in_cldecl_( = 27 );

  static _core_attr const ::CORBA::Octet LHand4 _init_in_cldecl_( = 28 );

  static _core_attr const ::CORBA::Octet LHand5 _init_in_cldecl_( = 29 );

  static _core_attr const ::CORBA::Octet LHand6 _init_in_cldecl_( = 30 );

  static _core_attr const ::CORBA::Octet LHand7 _init_in_cldecl_( = 31 );

  static _core_attr const ::CORBA::Octet NeckCam0 _init_in_cldecl_( = 32 );

  static _core_attr const ::CORBA::Octet NeckCam1 _init_in_cldecl_( = 33 );

  static _core_attr const ::CORBA::Octet NeckCam2 _init_in_cldecl_( = 34 );

  static _core_attr const ::CORBA::Octet NeckCam3 _init_in_cldecl_( = 35 );

  static _core_attr const ::CORBA::Octet NeckCam4 _init_in_cldecl_( = 36 );

  static _core_attr const ::CORBA::Octet NeckCam5 _init_in_cldecl_( = 37 );

  static _core_attr const ::CORBA::Octet NeckCam6 _init_in_cldecl_( = 38 );

  static _core_attr const ::CORBA::Octet NeckCam7 _init_in_cldecl_( = 39 );

  static _core_attr const ::CORBA::Octet ChestCam0 _init_in_cldecl_( = 40 );

  static _core_attr const ::CORBA::Octet ChestCam1 _init_in_cldecl_( = 41 );

  static _core_attr const ::CORBA::Octet ChestCam2 _init_in_cldecl_( = 42 );

  static _core_attr const ::CORBA::Octet ChestCam3 _init_in_cldecl_( = 43 );

  static _core_attr const ::CORBA::Octet ChestCam4 _init_in_cldecl_( = 44 );

  static _core_attr const ::CORBA::Octet ChestCam5 _init_in_cldecl_( = 45 );

  static _core_attr const ::CORBA::Octet ChestCam6 _init_in_cldecl_( = 46 );

  static _core_attr const ::CORBA::Octet ChestCam7 _init_in_cldecl_( = 47 );

  static _core_attr const ::CORBA::Octet NECK _init_in_cldecl_( = 1 );

  static _core_attr const ::CORBA::Octet CHEST _init_in_cldecl_( = 2 );

  static _core_attr const ::CORBA::Octet RIGHT_ARM _init_in_cldecl_( = 4 );

  static _core_attr const ::CORBA::Octet LEFT_ARM _init_in_cldecl_( = 8 );

  static _core_attr const ::CORBA::ULong InitializationStage _init_in_cldecl_( = 1U );

  static _core_attr const ::CORBA::ULong BusyError _init_in_cldecl_( = 2U );

  static _core_attr const ::CORBA::ULong SpeedSpecifyError _init_in_cldecl_( = 4U );

  static _core_attr const ::CORBA::ULong SpeedChangedWarning _init_in_cldecl_( = 8U );

  static _core_attr const ::CORBA::ULong InterpolatorInitError _init_in_cldecl_( = 16U );

  static _core_attr const ::CORBA::ULong SplinePathLengthTooLong _init_in_cldecl_( = 32U );

  static _core_attr const ::CORBA::ULong SplineCalculationError _init_in_cldecl_( = 64U );

  static _core_attr const ::CORBA::ULong IKErrorRight _init_in_cldecl_( = 256U );

  static _core_attr const ::CORBA::ULong WristCollisionErrorRight _init_in_cldecl_( = 512U );

  static _core_attr const ::CORBA::ULong IKErrorLeft _init_in_cldecl_( = 1024U );

  static _core_attr const ::CORBA::ULong WristCollisionErrorLeft _init_in_cldecl_( = 2048U );

  static _core_attr const ::CORBA::ULong EndPointCollisionError _init_in_cldecl_( = 4096U );

  static _core_attr const ::CORBA::ULong JointAngleLimitErrorRight _init_in_cldecl_( = 8192U );

  static _core_attr const ::CORBA::ULong JointAngleLimitErrorLeft _init_in_cldecl_( = 16384U );

  static _core_attr const ::CORBA::ULong JointAngleLimitErrorChest _init_in_cldecl_( = 32768U );

  static _core_attr const ::CORBA::ULong JointAngleLimitErrorNeck _init_in_cldecl_( = 65536U );

  static _core_attr const ::CORBA::ULong WristSynchronizationError _init_in_cldecl_( = 131072U );

  static _core_attr const ::CORBA::ULong MaxInterpolationTimeExceeded _init_in_cldecl_( = 262144U );

  static _core_attr const ::CORBA::ULong RotationMatrixError _init_in_cldecl_( = 524288U );

  static _core_attr const ::CORBA::ULong ProtectiveStopState _init_in_cldecl_( = 8388608U );

  static _core_attr const ::CORBA::ULong ServoEmergency _init_in_cldecl_( = 16777216U );

  static _core_attr const ::CORBA::ULong InterruptedRightArm _init_in_cldecl_( = 268435456U );

  static _core_attr const ::CORBA::ULong InterruptedLeftArm _init_in_cldecl_( = 536870912U );

  static _core_attr const ::CORBA::ULong InterruptedNeck _init_in_cldecl_( = 1073741824U );

  static _core_attr const ::CORBA::ULong InterruptedChest _init_in_cldecl_( = 2147483648U );

  static _core_attr const ::CORBA::LongLong JointCY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(1) );

  static _core_attr const ::CORBA::LongLong JointNY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(2) );

  static _core_attr const ::CORBA::LongLong JointNP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(4) );

  static _core_attr const ::CORBA::LongLong JointRSY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(8) );

  static _core_attr const ::CORBA::LongLong JointRSP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(16) );

  static _core_attr const ::CORBA::LongLong JointREP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(32) );

  static _core_attr const ::CORBA::LongLong JointRWY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(64) );

  static _core_attr const ::CORBA::LongLong JointRWP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(128) );

  static _core_attr const ::CORBA::LongLong JointRWR _init_in_cldecl_( = _CORBA_LONGLONG_CONST(256) );

  static _core_attr const ::CORBA::LongLong JointLSY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(512) );

  static _core_attr const ::CORBA::LongLong JointLSP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(1024) );

  static _core_attr const ::CORBA::LongLong JointLEP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(2048) );

  static _core_attr const ::CORBA::LongLong JointLWY _init_in_cldecl_( = _CORBA_LONGLONG_CONST(4096) );

  static _core_attr const ::CORBA::LongLong JointLWP _init_in_cldecl_( = _CORBA_LONGLONG_CONST(8192) );

  static _core_attr const ::CORBA::LongLong JointLWR _init_in_cldecl_( = _CORBA_LONGLONG_CONST(16384) );

  class LngLngSeq_var;

  class LngLngSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 >  {
  public:
    typedef LngLngSeq_var _var_type;
    inline LngLngSeq() {}
    inline LngLngSeq(const LngLngSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_s) {}

    inline LngLngSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max) {}
    inline LngLngSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::LongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline LngLngSeq& operator = (const LngLngSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class LngLngSeq_out;

  class LngLngSeq_var {
  public:
    inline LngLngSeq_var() : _pd_seq(0) {}
    inline LngLngSeq_var(LngLngSeq* _s) : _pd_seq(_s) {}
    inline LngLngSeq_var(const LngLngSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LngLngSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LngLngSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LngLngSeq_var& operator = (LngLngSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LngLngSeq_var& operator = (const LngLngSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LngLngSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LngLngSeq* operator -> () { return _pd_seq; }
    inline const LngLngSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LngLngSeq& () const { return *_pd_seq; }
#else
    inline operator const LngLngSeq& () const { return *_pd_seq; }
    inline operator LngLngSeq& () { return *_pd_seq; }
#endif
      
    inline const LngLngSeq& in() const { return *_pd_seq; }
    inline LngLngSeq&       inout()    { return *_pd_seq; }
    inline LngLngSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LngLngSeq* _retn() { LngLngSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LngLngSeq_out;
    
  private:
    LngLngSeq* _pd_seq;
  };

  class LngLngSeq_out {
  public:
    inline LngLngSeq_out(LngLngSeq*& _s) : _data(_s) { _data = 0; }
    inline LngLngSeq_out(LngLngSeq_var& _s)
      : _data(_s._pd_seq) { _s = (LngLngSeq*) 0; }
    inline LngLngSeq_out(const LngLngSeq_out& _s) : _data(_s._data) {}
    inline LngLngSeq_out& operator = (const LngLngSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LngLngSeq_out& operator = (LngLngSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator LngLngSeq*&()  { return _data; }
    inline LngLngSeq*& ptr()       { return _data; }
    inline LngLngSeq* operator->() { return _data; }

    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LngLngSeq*& _data;

  private:
    LngLngSeq_out();
    LngLngSeq_out& operator=(const LngLngSeq_var&);
  };

  typedef ::CORBA::Float FltArray15[15];
  typedef ::CORBA::Float FltArray15_slice;

  static inline FltArray15_slice* FltArray15_alloc() {
    return new FltArray15_slice[15];
  }

  static inline FltArray15_slice* FltArray15_dup(const FltArray15_slice* _s) {
    if (!_s) return 0;
    FltArray15_slice* _data = FltArray15_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  static inline void FltArray15_copy(FltArray15_slice* _to, const FltArray15_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  static inline void FltArray15_free(FltArray15_slice* _s) {
      delete [] _s;
  }

  class FltArray15_copyHelper {
  public:
    static inline FltArray15_slice* alloc() { return FltArray15_alloc(); }
    static inline FltArray15_slice* dup(const FltArray15_slice* p) { return FltArray15_dup(p); }
    static inline void free(FltArray15_slice* p) { FltArray15_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<FltArray15_copyHelper,FltArray15_slice> FltArray15_var;
  typedef _CORBA_Array_Fix_Forany<FltArray15_copyHelper,FltArray15_slice> FltArray15_forany;

  typedef FltArray15_slice* FltArray15_out;

  typedef ::CORBA::Boolean BolArray15[15];
  typedef ::CORBA::Boolean BolArray15_slice;

  static inline BolArray15_slice* BolArray15_alloc() {
    return new BolArray15_slice[15];
  }

  static inline BolArray15_slice* BolArray15_dup(const BolArray15_slice* _s) {
    if (!_s) return 0;
    BolArray15_slice* _data = BolArray15_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  static inline void BolArray15_copy(BolArray15_slice* _to, const BolArray15_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  static inline void BolArray15_free(BolArray15_slice* _s) {
      delete [] _s;
  }

  class BolArray15_copyHelper {
  public:
    static inline BolArray15_slice* alloc() { return BolArray15_alloc(); }
    static inline BolArray15_slice* dup(const BolArray15_slice* p) { return BolArray15_dup(p); }
    static inline void free(BolArray15_slice* p) { BolArray15_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<BolArray15_copyHelper,BolArray15_slice> BolArray15_var;
  typedef _CORBA_Array_Fix_Forany<BolArray15_copyHelper,BolArray15_slice> BolArray15_forany;

  typedef BolArray15_slice* BolArray15_out;

  typedef ::CORBA::LongLong LngArray15[15];
  typedef ::CORBA::LongLong LngArray15_slice;

  static inline LngArray15_slice* LngArray15_alloc() {
    return new LngArray15_slice[15];
  }

  static inline LngArray15_slice* LngArray15_dup(const LngArray15_slice* _s) {
    if (!_s) return 0;
    LngArray15_slice* _data = LngArray15_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  static inline void LngArray15_copy(LngArray15_slice* _to, const LngArray15_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 15; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  static inline void LngArray15_free(LngArray15_slice* _s) {
      delete [] _s;
  }

  class LngArray15_copyHelper {
  public:
    static inline LngArray15_slice* alloc() { return LngArray15_alloc(); }
    static inline LngArray15_slice* dup(const LngArray15_slice* p) { return LngArray15_dup(p); }
    static inline void free(LngArray15_slice* p) { LngArray15_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<LngArray15_copyHelper,LngArray15_slice> LngArray15_var;
  typedef _CORBA_Array_Fix_Forany<LngArray15_copyHelper,LngArray15_slice> LngArray15_forany;

  typedef LngArray15_slice* LngArray15_out;

  typedef ::CORBA::Long LngArray4[4];
  typedef ::CORBA::Long LngArray4_slice;

  static inline LngArray4_slice* LngArray4_alloc() {
    return new LngArray4_slice[4];
  }

  static inline LngArray4_slice* LngArray4_dup(const LngArray4_slice* _s) {
    if (!_s) return 0;
    LngArray4_slice* _data = LngArray4_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  static inline void LngArray4_copy(LngArray4_slice* _to, const LngArray4_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 4; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  static inline void LngArray4_free(LngArray4_slice* _s) {
      delete [] _s;
  }

  class LngArray4_copyHelper {
  public:
    static inline LngArray4_slice* alloc() { return LngArray4_alloc(); }
    static inline LngArray4_slice* dup(const LngArray4_slice* p) { return LngArray4_dup(p); }
    static inline void free(LngArray4_slice* p) { LngArray4_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<LngArray4_copyHelper,LngArray4_slice> LngArray4_var;
  typedef _CORBA_Array_Fix_Forany<LngArray4_copyHelper,LngArray4_slice> LngArray4_forany;

  typedef LngArray4_slice* LngArray4_out;

  typedef ::CORBA::Double DoubleArray6[6];
  typedef ::CORBA::Double DoubleArray6_slice;

  static inline DoubleArray6_slice* DoubleArray6_alloc() {
    return new DoubleArray6_slice[6];
  }

  static inline DoubleArray6_slice* DoubleArray6_dup(const DoubleArray6_slice* _s) {
    if (!_s) return 0;
    DoubleArray6_slice* _data = DoubleArray6_alloc();
    if (_data) {
      for (_CORBA_ULong _0i0 = 0; _0i0 < 6; _0i0++){
        
        _data[_0i0] = _s[_0i0];

      }
  
    }
    return _data;
  }

  static inline void DoubleArray6_copy(DoubleArray6_slice* _to, const DoubleArray6_slice* _from){
    for (_CORBA_ULong _0i0 = 0; _0i0 < 6; _0i0++){
      
      _to[_0i0] = _from[_0i0];

    }
  
  }

  static inline void DoubleArray6_free(DoubleArray6_slice* _s) {
      delete [] _s;
  }

  class DoubleArray6_copyHelper {
  public:
    static inline DoubleArray6_slice* alloc() { return DoubleArray6_alloc(); }
    static inline DoubleArray6_slice* dup(const DoubleArray6_slice* p) { return DoubleArray6_dup(p); }
    static inline void free(DoubleArray6_slice* p) { DoubleArray6_free(p); }
  };

  typedef _CORBA_Array_Fix_Var<DoubleArray6_copyHelper,DoubleArray6_slice> DoubleArray6_var;
  typedef _CORBA_Array_Fix_Forany<DoubleArray6_copyHelper,DoubleArray6_slice> DoubleArray6_forany;

  typedef DoubleArray6_slice* DoubleArray6_out;

  typedef DoubleArray6 Position;
  typedef DoubleArray6_slice Position_slice;
  typedef DoubleArray6_copyHelper Position_copyHelper;
  typedef DoubleArray6_var Position_var;
  typedef DoubleArray6_out Position_out;
  typedef DoubleArray6_forany Position_forany;

  static inline Position_slice* Position_alloc() { return DoubleArray6_alloc(); }
  static inline Position_slice* Position_dup(const Position_slice* p) { return DoubleArray6_dup(p); }
  static inline void Position_copy( Position_slice* _to, const Position_slice* _from ) { DoubleArray6_copy(_to, _from); }
  static inline void Position_free( Position_slice* p) { DoubleArray6_free(p); }

  class JointAngles_var;

  class JointAngles : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef JointAngles_var _var_type;
    inline JointAngles() {}
    inline JointAngles(const JointAngles& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline JointAngles(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline JointAngles(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline JointAngles& operator = (const JointAngles& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class JointAngles_out;

  class JointAngles_var {
  public:
    inline JointAngles_var() : _pd_seq(0) {}
    inline JointAngles_var(JointAngles* _s) : _pd_seq(_s) {}
    inline JointAngles_var(const JointAngles_var& _s) {
      if( _s._pd_seq )  _pd_seq = new JointAngles(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~JointAngles_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline JointAngles_var& operator = (JointAngles* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline JointAngles_var& operator = (const JointAngles_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new JointAngles;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline JointAngles* operator -> () { return _pd_seq; }
    inline const JointAngles* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator JointAngles& () const { return *_pd_seq; }
#else
    inline operator const JointAngles& () const { return *_pd_seq; }
    inline operator JointAngles& () { return *_pd_seq; }
#endif
      
    inline const JointAngles& in() const { return *_pd_seq; }
    inline JointAngles&       inout()    { return *_pd_seq; }
    inline JointAngles*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline JointAngles* _retn() { JointAngles* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class JointAngles_out;
    
  private:
    JointAngles* _pd_seq;
  };

  class JointAngles_out {
  public:
    inline JointAngles_out(JointAngles*& _s) : _data(_s) { _data = 0; }
    inline JointAngles_out(JointAngles_var& _s)
      : _data(_s._pd_seq) { _s = (JointAngles*) 0; }
    inline JointAngles_out(const JointAngles_out& _s) : _data(_s._data) {}
    inline JointAngles_out& operator = (const JointAngles_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline JointAngles_out& operator = (JointAngles* _s) {
      _data = _s;
      return *this;
    }
    inline operator JointAngles*&()  { return _data; }
    inline JointAngles*& ptr()       { return _data; }
    inline JointAngles* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    JointAngles*& _data;

  private:
    JointAngles_out();
    JointAngles_out& operator=(const JointAngles_var&);
  };

  class cs_Nums_var;

  class cs_Nums : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef cs_Nums_var _var_type;
    inline cs_Nums() {}
    inline cs_Nums(const cs_Nums& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline cs_Nums(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline cs_Nums(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline cs_Nums& operator = (const cs_Nums& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class cs_Nums_out;

  class cs_Nums_var {
  public:
    inline cs_Nums_var() : _pd_seq(0) {}
    inline cs_Nums_var(cs_Nums* _s) : _pd_seq(_s) {}
    inline cs_Nums_var(const cs_Nums_var& _s) {
      if( _s._pd_seq )  _pd_seq = new cs_Nums(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~cs_Nums_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline cs_Nums_var& operator = (cs_Nums* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline cs_Nums_var& operator = (const cs_Nums_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new cs_Nums;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline cs_Nums* operator -> () { return _pd_seq; }
    inline const cs_Nums* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator cs_Nums& () const { return *_pd_seq; }
#else
    inline operator const cs_Nums& () const { return *_pd_seq; }
    inline operator cs_Nums& () { return *_pd_seq; }
#endif
      
    inline const cs_Nums& in() const { return *_pd_seq; }
    inline cs_Nums&       inout()    { return *_pd_seq; }
    inline cs_Nums*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline cs_Nums* _retn() { cs_Nums* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class cs_Nums_out;
    
  private:
    cs_Nums* _pd_seq;
  };

  class cs_Nums_out {
  public:
    inline cs_Nums_out(cs_Nums*& _s) : _data(_s) { _data = 0; }
    inline cs_Nums_out(cs_Nums_var& _s)
      : _data(_s._pd_seq) { _s = (cs_Nums*) 0; }
    inline cs_Nums_out(const cs_Nums_out& _s) : _data(_s._data) {}
    inline cs_Nums_out& operator = (const cs_Nums_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline cs_Nums_out& operator = (cs_Nums* _s) {
      _data = _s;
      return *this;
    }
    inline operator cs_Nums*&()  { return _data; }
    inline cs_Nums*& ptr()       { return _data; }
    inline cs_Nums* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    cs_Nums*& _data;

  private:
    cs_Nums_out();
    cs_Nums_out& operator=(const cs_Nums_var&);
  };

  class CoordSequence_var;

  class CoordSequence : public _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< DoubleArray6, DoubleArray6_slice, ::CORBA::Double, 6, 8, 8 >  {
  public:
    typedef CoordSequence_var _var_type;
    inline CoordSequence() {}
    inline CoordSequence(const CoordSequence& _s)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< DoubleArray6, DoubleArray6_slice, ::CORBA::Double, 6, 8, 8 > (_s) {}

    inline CoordSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< DoubleArray6, DoubleArray6_slice, ::CORBA::Double, 6, 8, 8 > (_max) {}
    inline CoordSequence(_CORBA_ULong _max, _CORBA_ULong _len, DoubleArray6* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< DoubleArray6, DoubleArray6_slice, ::CORBA::Double, 6, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline CoordSequence& operator = (const CoordSequence& _s) {
      _CORBA_Unbounded_Sequence_Array_w_FixSizeElement< DoubleArray6, DoubleArray6_slice, ::CORBA::Double, 6, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class CoordSequence_out;

  class CoordSequence_var {
  public:
    inline CoordSequence_var() : _pd_seq(0) {}
    inline CoordSequence_var(CoordSequence* _s) : _pd_seq(_s) {}
    inline CoordSequence_var(const CoordSequence_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CoordSequence(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CoordSequence_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CoordSequence_var& operator = (CoordSequence* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CoordSequence_var& operator = (const CoordSequence_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CoordSequence;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline DoubleArray6_slice* operator [] (_CORBA_ULong _s) {
      return (DoubleArray6_slice*) ((_pd_seq->NP_data())[_s]);
    }

  

    inline CoordSequence* operator -> () { return _pd_seq; }
    inline const CoordSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CoordSequence& () const { return *_pd_seq; }
#else
    inline operator const CoordSequence& () const { return *_pd_seq; }
    inline operator CoordSequence& () { return *_pd_seq; }
#endif
      
    inline const CoordSequence& in() const { return *_pd_seq; }
    inline CoordSequence&       inout()    { return *_pd_seq; }
    inline CoordSequence*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CoordSequence* _retn() { CoordSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CoordSequence_out;
    
  private:
    CoordSequence* _pd_seq;
  };

  class CoordSequence_out {
  public:
    inline CoordSequence_out(CoordSequence*& _s) : _data(_s) { _data = 0; }
    inline CoordSequence_out(CoordSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CoordSequence*) 0; }
    inline CoordSequence_out(const CoordSequence_out& _s) : _data(_s._data) {}
    inline CoordSequence_out& operator = (const CoordSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CoordSequence_out& operator = (CoordSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CoordSequence*&()  { return _data; }
    inline CoordSequence*& ptr()       { return _data; }
    inline CoordSequence* operator->() { return _data; }

    inline DoubleArray6_slice* operator [] (_CORBA_ULong _i) {
      return (DoubleArray6_slice*) ((_data->NP_data())[_i]);
    }

  

    CoordSequence*& _data;

  private:
    CoordSequence_out();
    CoordSequence_out& operator=(const CoordSequence_var&);
  };

  static _core_attr const char * versionStringIDL;

  static _core_attr const char * versionDateIDL;


};

class _objref_coordServer :
  public virtual ::CORBA::Object,
  public virtual omniObjRef
{
public:
  ::CORBA::Boolean setCS(::CORBA::Octet cs_no, const char* cs_name, ::CORBA::Octet base_cs_no, const coordServer::Position cs_position, ::CORBA::ULong pass_no);
  void getCS(::CORBA::Octet cs_no, ::CORBA::String_out cs_name, ::CORBA::Octet& base_cs_no, coordServer::Position cs_position, ::CORBA::ULong& pass_no);
  ::CORBA::Boolean delCS(::CORBA::Octet cs_no, ::CORBA::ULong pass_no);
  ::CORBA::Boolean setPassNo(::CORBA::Octet cs_no, ::CORBA::ULong old_pass_no, ::CORBA::ULong new_pass_no);
  ::CORBA::Double moveTarget(::CORBA::Octet kind, ::CORBA::Octet base_cs_no, const coordServer::Position pos, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status);
  ::CORBA::Double movePatern(const coordServer::cs_Nums& csnums, const coordServer::CoordSequence& coord_sequence, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status);
  void getTarget(::CORBA::Octet base_cs_no, const coordServer::Position offset_pos, ::CORBA::Octet target_cs_no, ::CORBA::Octet kind, coordServer::Position pos);
  ::CORBA::Double setJointAngles(::CORBA::Octet part, const coordServer::JointAngles& joint_angles, ::CORBA::Double percent, ::CORBA::ULong& status);
  void getJointAngles(::CORBA::Octet part, ::CORBA::Octet kind, coordServer::JointAngles_out joint_angles);
  ::CORBA::ULong getStatus();
  ::CORBA::Boolean jointCalibration(const coordServer::LngLngSeq& seq, const coordServer::FltArray15 angles, const coordServer::BolArray15 rot, ::CORBA::ULong& status);
  ::CORBA::Boolean checkCalibration();
  ::CORBA::Boolean switchServo(::CORBA::Boolean t);
  ::CORBA::Boolean getServoStatus(coordServer::LngArray15 status);
  void protectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID);
  void exitProtectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID);
  ::CORBA::Boolean motionCancel(::CORBA::Octet& part);
  ::CORBA::Boolean inMotion(::CORBA::Octet& part, ::CORBA::Boolean wait);
  void getIDLVersionString(::CORBA::String_out revision, ::CORBA::String_out date);
  void getSrcVersionString(::CORBA::String_out revision, ::CORBA::String_out date);

  inline _objref_coordServer()  { _PR_setobj(0); }  // nil
  _objref_coordServer(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_coordServer();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_coordServer(const _objref_coordServer&);
  _objref_coordServer& operator = (const _objref_coordServer&);
  // not implemented

  friend class coordServer;
};

class _pof_coordServer : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_coordServer() : _OMNI_NS(proxyObjectFactory)(coordServer::_PD_repoId) {}
  virtual ~_pof_coordServer();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_coordServer :
  public virtual omniServant
{
public:
  virtual ~_impl_coordServer();

  virtual ::CORBA::Boolean setCS(::CORBA::Octet cs_no, const char* cs_name, ::CORBA::Octet base_cs_no, const coordServer::Position cs_position, ::CORBA::ULong pass_no) = 0;
  virtual void getCS(::CORBA::Octet cs_no, ::CORBA::String_out cs_name, ::CORBA::Octet& base_cs_no, coordServer::Position cs_position, ::CORBA::ULong& pass_no) = 0;
  virtual ::CORBA::Boolean delCS(::CORBA::Octet cs_no, ::CORBA::ULong pass_no) = 0;
  virtual ::CORBA::Boolean setPassNo(::CORBA::Octet cs_no, ::CORBA::ULong old_pass_no, ::CORBA::ULong new_pass_no) = 0;
  virtual ::CORBA::Double moveTarget(::CORBA::Octet kind, ::CORBA::Octet base_cs_no, const coordServer::Position pos, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status) = 0;
  virtual ::CORBA::Double movePatern(const coordServer::cs_Nums& csnums, const coordServer::CoordSequence& coord_sequence, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status) = 0;
  virtual void getTarget(::CORBA::Octet base_cs_no, const coordServer::Position offset_pos, ::CORBA::Octet target_cs_no, ::CORBA::Octet kind, coordServer::Position pos) = 0;
  virtual ::CORBA::Double setJointAngles(::CORBA::Octet part, const coordServer::JointAngles& joint_angles, ::CORBA::Double percent, ::CORBA::ULong& status) = 0;
  virtual void getJointAngles(::CORBA::Octet part, ::CORBA::Octet kind, coordServer::JointAngles_out joint_angles) = 0;
  virtual ::CORBA::ULong getStatus() = 0;
  virtual ::CORBA::Boolean jointCalibration(const coordServer::LngLngSeq& seq, const coordServer::FltArray15 angles, const coordServer::BolArray15 rot, ::CORBA::ULong& status) = 0;
  virtual ::CORBA::Boolean checkCalibration() = 0;
  virtual ::CORBA::Boolean switchServo(::CORBA::Boolean t) = 0;
  virtual ::CORBA::Boolean getServoStatus(coordServer::LngArray15 status) = 0;
  virtual void protectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID) = 0;
  virtual void exitProtectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID) = 0;
  virtual ::CORBA::Boolean motionCancel(::CORBA::Octet& part) = 0;
  virtual ::CORBA::Boolean inMotion(::CORBA::Octet& part, ::CORBA::Boolean wait) = 0;
  virtual void getIDLVersionString(::CORBA::String_out revision, ::CORBA::String_out date) = 0;
  virtual void getSrcVersionString(::CORBA::String_out revision, ::CORBA::String_out date) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};




class POA_coordServer :
  public virtual _impl_coordServer,
  public virtual ::PortableServer::ServantBase
{
public:
  virtual ~POA_coordServer();

  inline ::coordServer_ptr _this() {
    return (::coordServer_ptr) _do_this(::coordServer::_PD_repoId);
  }
};





template <class _omniT>
class POA_coordServer_tie : public virtual POA_coordServer
{
public:
  POA_coordServer_tie(_omniT& t)
    : pd_obj(&t), pd_poa(0), pd_rel(0) {}
  POA_coordServer_tie(_omniT& t, ::PortableServer::POA_ptr p)
    : pd_obj(&t), pd_poa(p), pd_rel(0) {}
  POA_coordServer_tie(_omniT* t, _CORBA_Boolean r=1)
    : pd_obj(t), pd_poa(0), pd_rel(r) {}
  POA_coordServer_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
    : pd_obj(t), pd_poa(p), pd_rel(r) {}
  ~POA_coordServer_tie() {
    if( pd_poa )  ::CORBA::release(pd_poa);
    if( pd_rel )  delete pd_obj;
  }

  _omniT* _tied_object() { return pd_obj; }

  void _tied_object(_omniT& t) {
    if( pd_rel )  delete pd_obj;
    pd_obj = &t;
    pd_rel = 0;
  }

  void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
    if( pd_rel )  delete pd_obj;
    pd_obj = t;
    pd_rel = r;
  }

  _CORBA_Boolean _is_owner()        { return pd_rel; }
  void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

  ::PortableServer::POA_ptr _default_POA() {
    if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
    else           return ::PortableServer::POA::_duplicate(pd_poa);
  }

  ::CORBA::Boolean setCS(::CORBA::Octet cs_no, const char* cs_name, ::CORBA::Octet base_cs_no, const coordServer::Position cs_position, ::CORBA::ULong pass_no) { return pd_obj->setCS(cs_no, cs_name, base_cs_no, cs_position, pass_no); }
  void getCS(::CORBA::Octet cs_no, ::CORBA::String_out cs_name, ::CORBA::Octet& base_cs_no, coordServer::Position cs_position, ::CORBA::ULong& pass_no) { pd_obj->getCS(cs_no, cs_name, base_cs_no, cs_position, pass_no); }
  ::CORBA::Boolean delCS(::CORBA::Octet cs_no, ::CORBA::ULong pass_no) { return pd_obj->delCS(cs_no, pass_no); }
  ::CORBA::Boolean setPassNo(::CORBA::Octet cs_no, ::CORBA::ULong old_pass_no, ::CORBA::ULong new_pass_no) { return pd_obj->setPassNo(cs_no, old_pass_no, new_pass_no); }
  ::CORBA::Double moveTarget(::CORBA::Octet kind, ::CORBA::Octet base_cs_no, const coordServer::Position pos, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status) { return pd_obj->moveTarget(kind, base_cs_no, pos, move_cs_no, percent, status); }
  ::CORBA::Double movePatern(const coordServer::cs_Nums& csnums, const coordServer::CoordSequence& coord_sequence, ::CORBA::Octet move_cs_no, ::CORBA::Double percent, ::CORBA::ULong& status) { return pd_obj->movePatern(csnums, coord_sequence, move_cs_no, percent, status); }
  void getTarget(::CORBA::Octet base_cs_no, const coordServer::Position offset_pos, ::CORBA::Octet target_cs_no, ::CORBA::Octet kind, coordServer::Position pos) { pd_obj->getTarget(base_cs_no, offset_pos, target_cs_no, kind, pos); }
  ::CORBA::Double setJointAngles(::CORBA::Octet part, const coordServer::JointAngles& joint_angles, ::CORBA::Double percent, ::CORBA::ULong& status) { return pd_obj->setJointAngles(part, joint_angles, percent, status); }
  void getJointAngles(::CORBA::Octet part, ::CORBA::Octet kind, coordServer::JointAngles_out joint_angles) { pd_obj->getJointAngles(part, kind, joint_angles); }
  ::CORBA::ULong getStatus() { return pd_obj->getStatus(); }
  ::CORBA::Boolean jointCalibration(const coordServer::LngLngSeq& seq, const coordServer::FltArray15 angles, const coordServer::BolArray15 rot, ::CORBA::ULong& status) { return pd_obj->jointCalibration(seq, angles, rot, status); }
  ::CORBA::Boolean checkCalibration() { return pd_obj->checkCalibration(); }
  ::CORBA::Boolean switchServo(::CORBA::Boolean t) { return pd_obj->switchServo(t); }
  ::CORBA::Boolean getServoStatus(coordServer::LngArray15 status) { return pd_obj->getServoStatus(status); }
  void protectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID) { pd_obj->protectiveStop(inputID, outputID); }
  void exitProtectiveStop(const coordServer::LngArray4 inputID, coordServer::LngArray4 outputID) { pd_obj->exitProtectiveStop(inputID, outputID); }
  ::CORBA::Boolean motionCancel(::CORBA::Octet& part) { return pd_obj->motionCancel(part); }
  ::CORBA::Boolean inMotion(::CORBA::Octet& part, ::CORBA::Boolean wait) { return pd_obj->inMotion(part, wait); }
  void getIDLVersionString(::CORBA::String_out revision, ::CORBA::String_out date) { pd_obj->getIDLVersionString(revision, date); }
  void getSrcVersionString(::CORBA::String_out revision, ::CORBA::String_out date) { pd_obj->getSrcVersionString(revision, date); }


private:
  _omniT*                   pd_obj;
  ::PortableServer::POA_ptr pd_poa;
  _CORBA_Boolean            pd_rel;
};



#undef _core_attr
#undef _dyn_attr



inline void
coordServer::_marshalObjRef(::coordServer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_coordServer
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_coordServer
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_coordServer
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_coordServer
#endif

#endif  // __coordServer_hh__

